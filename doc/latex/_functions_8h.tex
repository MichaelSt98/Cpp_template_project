\hypertarget{_functions_8h}{}\doxysection{learning\+Cpp/\+Basics/\+Functions.h File Reference}
\label{_functions_8h}\index{learningCpp/Basics/Functions.h@{learningCpp/Basics/Functions.h}}
{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
Include dependency graph for Functions.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=190pt]{_functions_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=181pt]{_functions_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{_functions_8h_af889c468d4cc52789ef37bf08716b68a}{pass\+\_\+by\+\_\+value}} (int x)
\begin{DoxyCompactList}\small\item\em Function passing argument by value. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_functions_8h_a5ec956d71e1eccd51ef422341e5f3049}{pass\+\_\+by\+\_\+reference}} (int \&x)
\begin{DoxyCompactList}\small\item\em Function passing argument by reference. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_functions_8h_a9ae15f6bff98d72da855b7b7816c8af3}{pass\+\_\+by\+\_\+address}} (int $\ast$x)
\begin{DoxyCompactList}\small\item\em Function passing argument by address. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_functions_8h_af8c77c8db78c984abd2c2d9526586d6a}{return\+\_\+by\+\_\+value}} ()
\begin{DoxyCompactList}\small\item\em Function returning value by value. \end{DoxyCompactList}\item 
int \& \mbox{\hyperlink{_functions_8h_ae748ac036cd3cb10bbb279962e5e9a7c}{return\+\_\+by\+\_\+reference}} ()
\begin{DoxyCompactList}\small\item\em Function returning value by reference. \end{DoxyCompactList}\item 
int $\ast$ \mbox{\hyperlink{_functions_8h_a3281d80fbae3ea726d13d7f2bdf21a3a}{return\+\_\+by\+\_\+address}} ()
\begin{DoxyCompactList}\small\item\em Function returning value by address. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_functions_8h_a8a24400242b18720c6ffef03116f165e}{overload\+\_\+add}} (int a, int b)
\begin{DoxyCompactList}\small\item\em Function adding two values. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_functions_8h_a460482522f520f74818976c486ad7809}{overload\+\_\+add}} (int a, int b, int c)
\begin{DoxyCompactList}\small\item\em (Overloaded) Function adding three values \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_functions_8h_a8346e6426fc45cf4b2a1142c2b24e987}{func\+\_\+default\+\_\+arg}} (int x, int y=10)
\begin{DoxyCompactList}\small\item\em Function with default argument (optional parameter) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5}{count\+Down}} (int count)
\begin{DoxyCompactList}\small\item\em A simple recursive function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_functions_8h_a69c7a90f893a6d7838dc10248edd16f2}{ellipsis\+\_\+example}} (int count,...)
\begin{DoxyCompactList}\small\item\em A simple function using ellipsis. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_functions_8h_abd9a6c9fecee433db5438afa8cae8670}{lambda\+\_\+example}} (std\+::array$<$ std\+::string\+\_\+view, 4 $>$ arr)
\begin{DoxyCompactList}\small\item\em A simple lambda function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{_functions_8h_a3f4ae913e2a7b3479faa6afe7c6948cd}{max}} (T x, T y)
\begin{DoxyCompactList}\small\item\em A simple template function. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\hypertarget{_functions_8h_autotoc_md123}{}\doxysubsection{Function parameters and arguments}\label{_functions_8h_autotoc_md123}
\hypertarget{_functions_8h_autotoc_md124}{}\doxysubsubsection{Pass by value}\label{_functions_8h_autotoc_md124}
By default, non-\/pointer arguments in C++ are passed by value. When an argument is {\bfseries{passed by value}}, the argument\textquotesingle{}s value is copied into the value of the corresponding function parameter. Therefore the original argument can not be modified by the function!\hypertarget{_functions_8h_autotoc_md125}{}\doxyparagraph{Pros}\label{_functions_8h_autotoc_md125}

\begin{DoxyItemize}
\item Arguments can be anything
\item Arguments are never changed by the function (prevents possibly unwanted side effects)
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md126}{}\doxyparagraph{Cons}\label{_functions_8h_autotoc_md126}

\begin{DoxyItemize}
\item Copying classes and structs can incur a significant performance penalty
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md127}{}\doxyparagraph{When to use}\label{_functions_8h_autotoc_md127}

\begin{DoxyItemize}
\item When passing fundamental data type and enumerators, and the function does not need to change the argument.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md128}{}\doxyparagraph{When not to use}\label{_functions_8h_autotoc_md128}

\begin{DoxyItemize}
\item When passing structs or classes (including std\+::array, std\+::vector, and std\+::string)
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md129}{}\doxysubsubsection{Pass by reference}\label{_functions_8h_autotoc_md129}
To {\bfseries{pass}} a variable {\bfseries{by reference}}, simply declare the function parameters as references. When the function is called the function parameter becomes a reference to the argument being called with, so that any changes made to the reference are passed through to the argument!

Since functions can have only one return value, references or rather reference function parameters can be used to return multiple values.\hypertarget{_functions_8h_autotoc_md130}{}\doxyparagraph{read-\/only pass by reference}\label{_functions_8h_autotoc_md130}
If it is undesirable to change an argument, make it read-\/only by passing it as {\bfseries{const reference}}, so that an error occurs if the function tries to change the argument.

That\textquotesingle{}s useful, since
\begin{DoxyItemize}
\item It enlists the compilers help in ensuring values that shouldn’t be changed aren’t changed (the compiler will throw an error if you try, like in the above example).
\item It tells the programmer that the function won’t change the value of the argument. This can help with debugging.
\item You can’t pass a const argument to a non-\/const reference parameter. Using const parameters ensures you can pass both non-\/const and const arguments to the function.
\item Const references can accept any type of argument, including non-\/const l-\/values, const l-\/values, and r-\/values.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md131}{}\doxyparagraph{Pros}\label{_functions_8h_autotoc_md131}

\begin{DoxyItemize}
\item References allow a function to change the value of the argument, which is sometimes useful. Otherwise, const references can be used to guarantee the function won’t change the argument.
\item Because a copy of the argument is not made, pass by reference is fast, even when used with large structs or classes.
\item References can be used to return multiple values from a function (via out parameters).
\item References must be initialized, so there’s no worry about null values.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md132}{}\doxyparagraph{Cons}\label{_functions_8h_autotoc_md132}

\begin{DoxyItemize}
\item Because a non-\/const reference cannot be initialized with a const l-\/value or an r-\/value (e.\+g. a literal or an expression), arguments to non-\/const reference parameters must be normal variables.
\item It can be hard to tell whether an argument passed by non-\/const reference is meant to be input, output, or both. Judicious use of const and a naming suffix for out variables can help.
\item It’s impossible to tell from the function call whether the argument may change. An argument passed by value and passed by reference looks the same. We can only tell whether an argument is passed by value or reference by looking at the function declaration. This can lead to situations where the programmer does not realize a function will change the value of the argument.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md133}{}\doxyparagraph{When to use}\label{_functions_8h_autotoc_md133}

\begin{DoxyItemize}
\item When passing structs or classes (const if read-\/only is wanted)
\item When the function needs to modify an argument
\item When the type information of a fixed array is required
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md134}{}\doxysubsubsection{Pass by address}\label{_functions_8h_autotoc_md134}
There is one more way to pass variables to functions, and that is by address. {\bfseries{Passing an argument by address}} involves passing the address of the argument variable rather than the argument variable itself. Because the argument is an address, the function parameter must be a pointer. The function can then dereference the pointer to access or change the value being pointed to.

{\bfseries{Remember that fixed arrays decay into pointers when passed to a function}}, therefore the length of the array has to be passed separately.

Addresses are actually passed by value, so by changing the function parameter itself, the original pointer argument will not be changed.

To change the address an argument points to, just pass the addresses by reference.\hypertarget{_functions_8h_autotoc_md135}{}\doxyparagraph{read-\/only pass by address}\label{_functions_8h_autotoc_md135}
If it is undesirable to change an argument, make it read-\/only by passing it as {\bfseries{const pointer}}, so that an error occurs if the function tries to change the argument.\hypertarget{_functions_8h_autotoc_md136}{}\doxyparagraph{Pros}\label{_functions_8h_autotoc_md136}

\begin{DoxyItemize}
\item Pass by address allows a function to change the value of the argument, which is sometimes useful. Otherwise, const can be used to guarantee the function won’t change the argument. (However, if you want to do this with a non-\/pointer, you should use pass by reference instead).
\item Because a copy of the argument is not made, it is fast, even when used with large structs or classes.
\item We can return multiple values from a function via out parameters.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md137}{}\doxyparagraph{Cons}\label{_functions_8h_autotoc_md137}

\begin{DoxyItemize}
\item Because literals (excepting C-\/style string literals) and expressions do not have addresses, pointer arguments must be normal variables.
\item All values must be checked to see whether they are null. Trying to dereference a null value will result in a crash. It is easy to forget to do this.
\item Because dereferencing a pointer is slower than accessing a value directly, accessing arguments passed by address is slower than accessing arguments passed by value.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md138}{}\doxyparagraph{When to use}\label{_functions_8h_autotoc_md138}

\begin{DoxyItemize}
\item When passing built-\/in arrays (if you’re okay with the fact that they’ll decay into a pointer).
\item When passing a pointer and nullptr is a valid argument logically.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md139}{}\doxyparagraph{When not to use}\label{_functions_8h_autotoc_md139}

\begin{DoxyItemize}
\item When passing a pointer and nullptr is not a valid argument logically (use pass by reference).
\item When passing structs or classes (use pass by reference).
\item When passing fundamental types (use pass by value).
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md140}{}\doxysubsubsection{Returning values by value, reference and address}\label{_functions_8h_autotoc_md140}
This is quite similar to passing arguments to functions. In fact, returning values from a function to its caller by value, address or reference {\bfseries{works almost exactly the same way as passing arguments to a function, with the same upsides and downsides}}.

{\bfseries{Attention}}\+: Since local variables in a function go out of scope and are destroyed, this needs to be considered!\hypertarget{_functions_8h_autotoc_md141}{}\doxyparagraph{Return by value}\label{_functions_8h_autotoc_md141}
To use, when
\begin{DoxyItemize}
\item returning variables that were declared inside the function
\item returning function arguments that were passed by value
\end{DoxyItemize}

{\bfseries{Not}} to use, when
\begin{DoxyItemize}
\item returning a built-\/in array or pointer (use return by address instead!)
\item returning a large struct or class (use return by reference instead!)
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md142}{}\doxyparagraph{Return by address}\label{_functions_8h_autotoc_md142}
Not possible for literals or expressions (no address)!

To use, when
\begin{DoxyItemize}
\item returning dynamically allocated memory and there is no type to handle the allocation
\item returning function arguments that were passed by address
\end{DoxyItemize}

{\bfseries{Not}} to use, when
\begin{DoxyItemize}
\item returning variables declared inside the function or parameters passed by value (use return by value instead!)
\item returning a large struct or class that was passed by reference (use return by refernce instead!)
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md143}{}\doxysubsubsection{Return by reference}\label{_functions_8h_autotoc_md143}
Not possible for literals or expressions (no address)!

To use, when
\begin{DoxyItemize}
\item returning a reference parameter
\item returning a member of an object that was passed into the function by reference or address
\item returning a large struct or class that will not be destroyed at the end of the function
\end{DoxyItemize}

{\bfseries{Not}} to use, when
\begin{DoxyItemize}
\item returning variables declared inside the function or parameters passed by value (use return by value instead!)
\item returning a built-\/in array or pointer value (use return by address)
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md144}{}\doxysubsubsection{Returning multiple values}\label{_functions_8h_autotoc_md144}
To return multiple values
\begin{DoxyItemize}
\item a struct (or in principle a class)
\item std\+::tuple can be used!
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md145}{}\doxysubsection{Function overloading}\label{_functions_8h_autotoc_md145}
{\bfseries{Function overloading is a feature of C++ that allows us to create multiple functions with the same name, so long as they have different parameters.}}

{\bfseries{Attention\+:}} Function return types are not considered distinct!\hypertarget{_functions_8h_autotoc_md146}{}\doxysubsection{Default arguments}\label{_functions_8h_autotoc_md146}
A default argument is a default value provided for a function parameter. If the user does not supply an explicit argument for a parameter with a default argument, the default value will be used. If the user does supply an argument for the parameter, the user-\/supplied argument is used. Because the user can choose whether to supply a specific argument value, or use the default, a parameter with a default value provided is often called an optional parameter.\hypertarget{_functions_8h_autotoc_md147}{}\doxysubsection{Function pointers}\label{_functions_8h_autotoc_md147}
{\bfseries{Function pointers}} point to functions!


\begin{DoxyItemize}
\item non-\/const function pointer\+: int ({\itshape fcn\+Ptr)()}
\item {\itshape const function pointer\+: int ($\ast$const fcn\+Ptr)()}
\item {\itshape use type aliases to make function pointers $\ast$prettier}\+: using Validate\+Function = bool($\ast$)(int, int)
\item using std\+::function (from e.\+g. $<$functional$>$)\+: std\+::function$<$bool(int, int)$>$ fcn
\end{DoxyItemize}

Using function pointers, functions can be passed to other functions as arguments.\hypertarget{_functions_8h_autotoc_md148}{}\doxysubsection{The stack and the heap}\label{_functions_8h_autotoc_md148}
The memory a program uses is divided into\+:


\begin{DoxyItemize}
\item The code segment (also called a text segment), where the compiled program sits in memory. The code segment is typically read-\/only.
\item The bss segment (also called the uninitialized data segment), where zero-\/initialized global and static variables are stored.
\item The data segment (also called the initialized data segment), where initialized global and static variables are stored.
\item The heap, where dynamically allocated variables are allocated from.
\item The call stack, where function parameters, local variables, and other function-\/related information are stored.
\end{DoxyItemize}\hypertarget{_functions_8h_autotoc_md149}{}\doxysubsubsection{Heap}\label{_functions_8h_autotoc_md149}
The heap segment (also known as the “free store”) keeps track of memory used for dynamic memory allocation (when using {\itshape new} and {\itshape delete}).\hypertarget{_functions_8h_autotoc_md150}{}\doxysubsubsection{Stack}\label{_functions_8h_autotoc_md150}
The call stack (usually referred to as “the stack”) has a much more interesting role to play. The call stack keeps track of all the active functions (those that have been called but have not yet terminated) from the start of the program to the current point of execution, and handles allocation of all function parameters and local variables.\hypertarget{_functions_8h_autotoc_md151}{}\doxysubsection{Recursion}\label{_functions_8h_autotoc_md151}
Recursive functions are functions that call themselves.\hypertarget{_functions_8h_autotoc_md152}{}\doxysubsection{Variable number of parameters -\/ Ellipsis}\label{_functions_8h_autotoc_md152}
All parameters a function will take must be known in advance (even if they have default values). However, there are certain cases where it can be useful to be able to pass a variable number of parameters to a function. C++ provides a special specifier known as ellipsis $\ast$...$\ast$.

{\bfseries{Avoid using ellipsis, for many reasons ... !}}\hypertarget{_functions_8h_autotoc_md153}{}\doxysubsection{Lambdas -\/ anonymous functions}\label{_functions_8h_autotoc_md153}
See \href{https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/}{\texttt{ Lambdas}} for reference!

A {\bfseries{lambda expression}} (also {\itshape lambda} or {\itshape closure}) allows to define an anonymous function inside another function.

The syntax is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{[ captureClause ] ( parameters ) -\/> returnType}
\DoxyCodeLine{\{}
\DoxyCodeLine{    statements;}
\DoxyCodeLine{\}}
\end{DoxyCode}


Consequently a trivial lambda looks like\+: {\ttfamily \mbox{[}\mbox{]}() \{\}}.

In actuality, lambdas aren’t functions (which is part of how they avoid the limitation of C++ not supporting nested functions). They’re a special kind of object called a {\bfseries{functor}}. {\bfseries{Functors}} are objects that contain an overloaded operator() that make them callable like a function.

{\bfseries{Use auto when initializing variables with lambdas, and std\+::function if you can’t initialize the variable with the lambda.}}\hypertarget{_functions_8h_autotoc_md154}{}\doxysubsection{Function templates}\label{_functions_8h_autotoc_md154}


Definition in file \mbox{\hyperlink{_functions_8h_source}{Functions.\+h}}.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5}\label{_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5}} 
\index{Functions.h@{Functions.h}!countDown@{countDown}}
\index{countDown@{countDown}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{countDown()}{countDown()}}
{\footnotesize\ttfamily void count\+Down (\begin{DoxyParamCaption}\item[{int}]{count }\end{DoxyParamCaption})}



A simple recursive function. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00057}{57}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00058 \{}
\DoxyCodeLine{00059     std::cout << \textcolor{stringliteral}{"{}push "{}} << count << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00060 }
\DoxyCodeLine{00061     \textcolor{keywordflow}{if} (count > 1) \textcolor{comment}{// termination condition}}
\DoxyCodeLine{00062         \mbox{\hyperlink{_functions_8cpp_a5efc0d291d6f7ee1784b2c23409adbf5}{countDown}}(count-\/1);}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064     std::cout << \textcolor{stringliteral}{"{}pop "{}} << count << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00065 \}}

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{_functions_8h_a69c7a90f893a6d7838dc10248edd16f2}\label{_functions_8h_a69c7a90f893a6d7838dc10248edd16f2}} 
\index{Functions.h@{Functions.h}!ellipsis\_example@{ellipsis\_example}}
\index{ellipsis\_example@{ellipsis\_example}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{ellipsis\_example()}{ellipsis\_example()}}
{\footnotesize\ttfamily void ellipsis\+\_\+example (\begin{DoxyParamCaption}\item[{int}]{count,  }\item[{}]{... }\end{DoxyParamCaption})}



A simple function using ellipsis. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00083}{83}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00083                                       \{}
\DoxyCodeLine{00084     \textcolor{keywordtype}{double} sum\{ 0 \};}
\DoxyCodeLine{00085 }
\DoxyCodeLine{00086     \textcolor{comment}{// We access the ellipsis through a va\_list, so let's declare one}}
\DoxyCodeLine{00087     va\_list list;}
\DoxyCodeLine{00088 }
\DoxyCodeLine{00089     \textcolor{comment}{// We initialize the va\_list using va\_start.  The first parameter is}}
\DoxyCodeLine{00090     \textcolor{comment}{// the list to initialize.  The second parameter is the last non-\/ellipsis}}
\DoxyCodeLine{00091     \textcolor{comment}{// parameter.}}
\DoxyCodeLine{00092     va\_start(list, count);}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     \textcolor{comment}{// Loop through all the ellipsis arguments}}
\DoxyCodeLine{00095     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} arg\{ 0 \}; arg < count; ++arg)}
\DoxyCodeLine{00096     \{}
\DoxyCodeLine{00097         \textcolor{comment}{// We use va\_arg to get parameters out of our ellipsis}}
\DoxyCodeLine{00098         \textcolor{comment}{// The first parameter is the va\_list we're using}}
\DoxyCodeLine{00099         \textcolor{comment}{// The second parameter is the type of the parameter}}
\DoxyCodeLine{00100         sum += va\_arg(list, \textcolor{keywordtype}{int});}
\DoxyCodeLine{00101     \}}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103     \textcolor{comment}{// Cleanup the va\_list when we're done.}}
\DoxyCodeLine{00104     va\_end(list);}
\DoxyCodeLine{00105 }
\DoxyCodeLine{00106     std::cout << \textcolor{stringliteral}{"{}average = "{}} << sum / count << std::endl;}
\DoxyCodeLine{00107 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a8346e6426fc45cf4b2a1142c2b24e987}\label{_functions_8h_a8346e6426fc45cf4b2a1142c2b24e987}} 
\index{Functions.h@{Functions.h}!func\_default\_arg@{func\_default\_arg}}
\index{func\_default\_arg@{func\_default\_arg}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{func\_default\_arg()}{func\_default\_arg()}}
{\footnotesize\ttfamily void func\+\_\+default\+\_\+arg (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y = {\ttfamily 10} }\end{DoxyParamCaption})}



Function with default argument (optional parameter) 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00052}{52}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00052                                     \{}
\DoxyCodeLine{00053     std::cout << \textcolor{stringliteral}{"{}x = "{}} << x << std::endl;}
\DoxyCodeLine{00054     std::cout << \textcolor{stringliteral}{"{}y = "{}} << y << std::endl;}
\DoxyCodeLine{00055 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_abd9a6c9fecee433db5438afa8cae8670}\label{_functions_8h_abd9a6c9fecee433db5438afa8cae8670}} 
\index{Functions.h@{Functions.h}!lambda\_example@{lambda\_example}}
\index{lambda\_example@{lambda\_example}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{lambda\_example()}{lambda\_example()}}
{\footnotesize\ttfamily void lambda\+\_\+example (\begin{DoxyParamCaption}\item[{std\+::array$<$ std\+::string\+\_\+view, 4 $>$}]{arr }\end{DoxyParamCaption})}



A simple lambda function. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00067}{67}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00067                                                      \{}
\DoxyCodeLine{00068     \textcolor{keyword}{const} \textcolor{keyword}{auto} found\{ std::find\_if(arr.begin(), arr.end(),}
\DoxyCodeLine{00069                                    [](std::string\_view str) \textcolor{comment}{// here's our lambda, no capture clause}}
\DoxyCodeLine{00070                                    \{}
\DoxyCodeLine{00071                                        return (str.find(\textcolor{stringliteral}{"{}nut"{}}) != std::string\_view::npos);}
\DoxyCodeLine{00072                                    \}) \};}
\DoxyCodeLine{00073 }
\DoxyCodeLine{00074     \textcolor{keywordflow}{if} (found == arr.end())}
\DoxyCodeLine{00075     \{}
\DoxyCodeLine{00076         std::cout << \textcolor{stringliteral}{"{}No nuts\(\backslash\)n"{}};}
\DoxyCodeLine{00077     \}}
\DoxyCodeLine{00078     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00079         std::cout << \textcolor{stringliteral}{"{}Found "{}} << *found << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00080     \}}
\DoxyCodeLine{00081 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a3f4ae913e2a7b3479faa6afe7c6948cd}\label{_functions_8h_a3f4ae913e2a7b3479faa6afe7c6948cd}} 
\index{Functions.h@{Functions.h}!max@{max}}
\index{max@{max}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{max()}{max()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T max (\begin{DoxyParamCaption}\item[{T}]{x,  }\item[{T}]{y }\end{DoxyParamCaption})}



A simple template function. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00109}{109}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00109                                       \{}
\DoxyCodeLine{00110     \textcolor{keywordflow}{return} (x > y) ? x : y;}
\DoxyCodeLine{00111 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a8a24400242b18720c6ffef03116f165e}\label{_functions_8h_a8a24400242b18720c6ffef03116f165e}} 
\index{Functions.h@{Functions.h}!overload\_add@{overload\_add}}
\index{overload\_add@{overload\_add}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{overload\_add()}{overload\_add()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int overload\+\_\+add (\begin{DoxyParamCaption}\item[{int}]{a,  }\item[{int}]{b }\end{DoxyParamCaption})}



Function adding two values. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00042}{42}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00042                                \{}
\DoxyCodeLine{00043     std::cout << \textcolor{stringliteral}{"{}overload\_add(int a, int b)"{}} << std::endl;}
\DoxyCodeLine{00044     \textcolor{keywordflow}{return} a + b;}
\DoxyCodeLine{00045 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a460482522f520f74818976c486ad7809}\label{_functions_8h_a460482522f520f74818976c486ad7809}} 
\index{Functions.h@{Functions.h}!overload\_add@{overload\_add}}
\index{overload\_add@{overload\_add}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{overload\_add()}{overload\_add()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int overload\+\_\+add (\begin{DoxyParamCaption}\item[{int}]{a,  }\item[{int}]{b,  }\item[{int}]{c }\end{DoxyParamCaption})}



(Overloaded) Function adding three values 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00047}{47}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00047                                       \{}
\DoxyCodeLine{00048     std::cout << \textcolor{stringliteral}{"{}overload\_add(int a, int b, int c)"{}} << std::endl;}
\DoxyCodeLine{00049     \textcolor{keywordflow}{return} a + b + c;}
\DoxyCodeLine{00050 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a9ae15f6bff98d72da855b7b7816c8af3}\label{_functions_8h_a9ae15f6bff98d72da855b7b7816c8af3}} 
\index{Functions.h@{Functions.h}!pass\_by\_address@{pass\_by\_address}}
\index{pass\_by\_address@{pass\_by\_address}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{pass\_by\_address()}{pass\_by\_address()}}
{\footnotesize\ttfamily void pass\+\_\+by\+\_\+address (\begin{DoxyParamCaption}\item[{int $\ast$}]{x }\end{DoxyParamCaption})}



Function passing argument by address. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00018}{18}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00018                                \{}
\DoxyCodeLine{00019     std::cout << \textcolor{stringliteral}{"{}func: pass\_by\_address(int *ptr)"{}} << std::endl;}
\DoxyCodeLine{00020     std::cout << \textcolor{stringliteral}{"{}ptr = 4"{}} << std::endl;}
\DoxyCodeLine{00021     *ptr = 4;}
\DoxyCodeLine{00022 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a5ec956d71e1eccd51ef422341e5f3049}\label{_functions_8h_a5ec956d71e1eccd51ef422341e5f3049}} 
\index{Functions.h@{Functions.h}!pass\_by\_reference@{pass\_by\_reference}}
\index{pass\_by\_reference@{pass\_by\_reference}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{pass\_by\_reference()}{pass\_by\_reference()}}
{\footnotesize\ttfamily void pass\+\_\+by\+\_\+reference (\begin{DoxyParamCaption}\item[{int \&}]{x }\end{DoxyParamCaption})}



Function passing argument by reference. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00012}{12}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00012                                \{}
\DoxyCodeLine{00013     std::cout << \textcolor{stringliteral}{"{}func: pass\_by\_reference(int \&x)"{}} << std::endl;}
\DoxyCodeLine{00014     std::cout << \textcolor{stringliteral}{"{}x += 1"{}} << std::endl;}
\DoxyCodeLine{00015     x = x + 1;}
\DoxyCodeLine{00016 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_af889c468d4cc52789ef37bf08716b68a}\label{_functions_8h_af889c468d4cc52789ef37bf08716b68a}} 
\index{Functions.h@{Functions.h}!pass\_by\_value@{pass\_by\_value}}
\index{pass\_by\_value@{pass\_by\_value}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{pass\_by\_value()}{pass\_by\_value()}}
{\footnotesize\ttfamily void pass\+\_\+by\+\_\+value (\begin{DoxyParamCaption}\item[{int}]{x }\end{DoxyParamCaption})}



Function passing argument by value. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00007}{7}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00007                           \{}
\DoxyCodeLine{00008     std::cout << \textcolor{stringliteral}{"{}func: pass\_by\_value(int x)"{}} << std::endl;}
\DoxyCodeLine{00009     std::cout << \textcolor{stringliteral}{"{}x = "{}} << x << std::endl;}
\DoxyCodeLine{00010 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_a3281d80fbae3ea726d13d7f2bdf21a3a}\label{_functions_8h_a3281d80fbae3ea726d13d7f2bdf21a3a}} 
\index{Functions.h@{Functions.h}!return\_by\_address@{return\_by\_address}}
\index{return\_by\_address@{return\_by\_address}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{return\_by\_address()}{return\_by\_address()}}
{\footnotesize\ttfamily int$\ast$ return\+\_\+by\+\_\+address (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Function returning value by address. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00036}{36}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00036                          \{}
\DoxyCodeLine{00037     std::cout << \textcolor{stringliteral}{"{}func: return\_by\_address()"{}} << std::endl;}
\DoxyCodeLine{00038     \textcolor{keywordtype}{int} value\{ 2 \};}
\DoxyCodeLine{00039     \textcolor{keywordflow}{return} \&value; \textcolor{comment}{// return value by address}}
\DoxyCodeLine{00040 \} \textcolor{comment}{// value destroyed here}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_ae748ac036cd3cb10bbb279962e5e9a7c}\label{_functions_8h_ae748ac036cd3cb10bbb279962e5e9a7c}} 
\index{Functions.h@{Functions.h}!return\_by\_reference@{return\_by\_reference}}
\index{return\_by\_reference@{return\_by\_reference}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{return\_by\_reference()}{return\_by\_reference()}}
{\footnotesize\ttfamily int\& return\+\_\+by\+\_\+reference (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Function returning value by reference. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00030}{30}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00030                            \{}
\DoxyCodeLine{00031     std::cout << \textcolor{stringliteral}{"{}func: return\_by\_reference()"{}} << std::endl;}
\DoxyCodeLine{00032     \textcolor{keywordtype}{int} value\{ 2 \};}
\DoxyCodeLine{00033     \textcolor{keywordflow}{return} value; \textcolor{comment}{// return a refernce to value}}
\DoxyCodeLine{00034 \}}

\end{DoxyCode}
\mbox{\Hypertarget{_functions_8h_af8c77c8db78c984abd2c2d9526586d6a}\label{_functions_8h_af8c77c8db78c984abd2c2d9526586d6a}} 
\index{Functions.h@{Functions.h}!return\_by\_value@{return\_by\_value}}
\index{return\_by\_value@{return\_by\_value}!Functions.h@{Functions.h}}
\doxysubsubsection{\texorpdfstring{return\_by\_value()}{return\_by\_value()}}
{\footnotesize\ttfamily int return\+\_\+by\+\_\+value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Function returning value by value. 



Definition at line \mbox{\hyperlink{_functions_8cpp_source_l00024}{24}} of file \mbox{\hyperlink{_functions_8cpp_source}{Functions.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00024                       \{}
\DoxyCodeLine{00025     std::cout << \textcolor{stringliteral}{"{}func: return\_by\_value()"{}} << std::endl;}
\DoxyCodeLine{00026     \textcolor{keywordtype}{int} value\{ 2 \};}
\DoxyCodeLine{00027     \textcolor{keywordflow}{return} value; \textcolor{comment}{// a copy of value will be returned}}
\DoxyCodeLine{00028 \} \textcolor{comment}{// value desroyed here}}

\end{DoxyCode}
