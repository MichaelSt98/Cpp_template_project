\hypertarget{_pointers_8cpp_source}{}\doxysection{Pointers.\+cpp}
\label{_pointers_8cpp_source}\index{src/Pointers.cpp@{src/Pointers.cpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//}}
\DoxyCodeLine{00002 \textcolor{comment}{// Created by Michael Staneker on 03.12.20.}}
\DoxyCodeLine{00003 \textcolor{comment}{//}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00006 }
\DoxyCodeLine{\Hypertarget{_pointers_8cpp_source_l00018}\mbox{\hyperlink{_pointers_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{00018}} \textcolor{keywordtype}{int} \mbox{\hyperlink{_pointers_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}() \{}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020     \textcolor{keywordtype}{int} x\{ 5 \};}
\DoxyCodeLine{00021     std::cout << \textcolor{stringliteral}{"{}    x = "{}} << x << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print the value of variable x}}
\DoxyCodeLine{00022 }
\DoxyCodeLine{00024     std::cout << \textcolor{stringliteral}{"{}   \&x = "{}} << \&x << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print the memory address of variable x}}
\DoxyCodeLine{00028 \textcolor{comment}{}    std::cout << \textcolor{stringliteral}{"{}*(\&x) = "{}} << *(\&x) << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print the memory address of variable x}}
\DoxyCodeLine{00032 \textcolor{comment}{}    \textcolor{comment}{//int *iPtr\{\}; // a pointer to an integer value}}
\DoxyCodeLine{00033     \textcolor{comment}{//double *dPtr\{\}; // a pointer to a double value}}
\DoxyCodeLine{00034     \textcolor{comment}{//int* iPtr2\{\}; // also valid syntax (acceptable, but not favored)}}
\DoxyCodeLine{00035     \textcolor{comment}{//int * iPtr3\{\}; // also valid syntax (but don't do this, it looks like multiplication)}}
\DoxyCodeLine{00036     \textcolor{comment}{//int *iPtr4\{\}, *iPtr5\{\}; // declare two pointers to integer variables (not recommended)}}
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038     \textcolor{keywordtype}{int} var\{ 5 \};}
\DoxyCodeLine{00039     \textcolor{keywordtype}{int} *ptr\{ \&var \}; \textcolor{comment}{// initialize ptr with address of variable v}}
\DoxyCodeLine{00040     std::cout << \textcolor{stringliteral}{"{}var = "{}} << var << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print the address of variable v}}
\DoxyCodeLine{00041     std::cout << \textcolor{stringliteral}{"{}var = "{}} << \&var << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print the address of variable v}}
\DoxyCodeLine{00042     std::cout << \textcolor{stringliteral}{"{}ptr = "{}} << ptr << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print the address that ptr is holding}}
\DoxyCodeLine{00043     std::cout << \textcolor{stringliteral}{"{}*ptr = "{}} << *ptr << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00044 }
\DoxyCodeLine{00045     \textcolor{comment}{//    Pointers are good for:}}
\DoxyCodeLine{00046     \textcolor{comment}{//    * dynamic arrays}}
\DoxyCodeLine{00047     \textcolor{comment}{//    * dynamically allocate memory}}
\DoxyCodeLine{00048     \textcolor{comment}{//    * pass large amount of data to a function (without copying)}}
\DoxyCodeLine{00049     \textcolor{comment}{//    * pass a function as a parameter to another function}}
\DoxyCodeLine{00050     \textcolor{comment}{//    * achieve polymorphism when dealing with inheritance}}
\DoxyCodeLine{00051     \textcolor{comment}{//    * useful for advanced data structures}}
\DoxyCodeLine{00055 \textcolor{comment}{}    \textcolor{comment}{//assigning it to the literal 0}}
\DoxyCodeLine{00056     \textcolor{keywordtype}{float} *null\_ptr \{ 0 \};  \textcolor{comment}{// ptr is now a null pointer}}
\DoxyCodeLine{00057     \textcolor{keywordtype}{float} *null\_ptr2; \textcolor{comment}{// ptr2 is uninitialized}}
\DoxyCodeLine{00058     null\_ptr2 = 0; \textcolor{comment}{// ptr2 is now a null pointer}}
\DoxyCodeLine{00059     \textcolor{keywordtype}{float} *null\_ptr3 \{\textcolor{keyword}{nullptr}\}; \textcolor{comment}{// C++11}}
\DoxyCodeLine{00063 \textcolor{comment}{}    \textcolor{keywordtype}{int} array[5]\{ 9, 7, 5, 3, 1 \};}
\DoxyCodeLine{00064     std::cout << *array << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// will print 9}}
\DoxyCodeLine{00065     \textcolor{keywordtype}{int} *ptr\_for\_array\{ array \};}
\DoxyCodeLine{00066     std::cout << *ptr\_for\_array << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// will print 9}}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068     \textcolor{comment}{// ARRAYS DECAY INTO POINTERS WHEN PASSED TO FUNCTIONS !!!}}
\DoxyCodeLine{00075 \textcolor{comment}{}    std::cout << \&array[1] << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print memory address of array element 1}}
\DoxyCodeLine{00076     std::cout << array+1 << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// print memory address of array pointer + 1}}
\DoxyCodeLine{00077     std::cout << array[1] << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// prints 7}}
\DoxyCodeLine{00078     std::cout << *(array+1) << \textcolor{charliteral}{'\(\backslash\)n'}; \textcolor{comment}{// prints 7 (note the parenthesis required here)}}
\DoxyCodeLine{00087 \textcolor{comment}{}    \textcolor{comment}{//new int; // dynamically allocate an integer (and discard the result)}}
\DoxyCodeLine{00088     \textcolor{keywordtype}{int} *ptr\_dyn\{ \textcolor{keyword}{new} \textcolor{keywordtype}{int} \}; \textcolor{comment}{// dynamically allocate an integer and assign the address to ptr so we can access it later}}
\DoxyCodeLine{00089     *ptr\_dyn = 7;}
\DoxyCodeLine{00090     \textcolor{comment}{// equivalent: int *ptr\_dyn\{ new int \{ 7 \}\}}}
\DoxyCodeLine{00091     std::cout << \textcolor{stringliteral}{"{}ptr\_dyn = "{}} << ptr\_dyn << std::endl;}
\DoxyCodeLine{00092     std::cout << \textcolor{stringliteral}{"{}*ptr\_dyn = "{}} << *ptr\_dyn << std::endl;}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     \textcolor{comment}{// delete}}
\DoxyCodeLine{00095     \textcolor{keyword}{delete} ptr\_dyn; \textcolor{comment}{// return the memory pointed to by ptr to the operating system}}
\DoxyCodeLine{00096     ptr\_dyn = 0; \textcolor{comment}{// set ptr to be a null pointer (use nullptr instead of 0 in C++11)}}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098 }
\DoxyCodeLine{00099     \textcolor{comment}{// Dynamically allocating arrays}}
\DoxyCodeLine{00100     \textcolor{keywordtype}{int} *dyn\_array\{ \textcolor{keyword}{new} \textcolor{keywordtype}{int}[5]\{ 9, 7, 5, 3, 1 \} \}; \textcolor{comment}{// initialize a dynamic array since C++11}}
\DoxyCodeLine{00101     \textcolor{comment}{// To prevent writing the type twice, we can use auto. This is often done for types with long names.}}
\DoxyCodeLine{00102     \textcolor{comment}{//auto *array\{ new int[5]\{ 9, 7, 5, 3, 1 \} \};}}
\DoxyCodeLine{00103     \textcolor{keyword}{delete} [] dyn\_array;}
\DoxyCodeLine{00113     \textcolor{keywordtype}{int} nValue;}
\DoxyCodeLine{00114     \textcolor{keywordtype}{float} fValue;}
\DoxyCodeLine{00115     \textcolor{keyword}{struct }Something}
\DoxyCodeLine{00116     \{}
\DoxyCodeLine{00117         \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{00118         \textcolor{keywordtype}{float} f;}
\DoxyCodeLine{00119     \};}
\DoxyCodeLine{00120     Something sValue;}
\DoxyCodeLine{00121     \textcolor{keywordtype}{void} *void\_ptr;}
\DoxyCodeLine{00122     void\_ptr = \&nValue; \textcolor{comment}{// valid}}
\DoxyCodeLine{00123     void\_ptr = \&fValue; \textcolor{comment}{// valid}}
\DoxyCodeLine{00124     void\_ptr = \&sValue; \textcolor{comment}{// valid}}
\DoxyCodeLine{00125     \textcolor{comment}{// ATTENTION: indirection is only possible using a cast}}
\DoxyCodeLine{00134 \textcolor{comment}{}    \textcolor{keywordtype}{int} value\_for\_pointer = 5;}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136     \textcolor{keywordtype}{int} *primary\_ptr = \&value\_for\_pointer;}
\DoxyCodeLine{00137     std::cout << \textcolor{stringliteral}{"{}ptr = "{}} << *primary\_ptr << std::endl; \textcolor{comment}{// Indirection through pointer to int to get int value}}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139     \textcolor{keywordtype}{int} **ptrptr = \&primary\_ptr;}
\DoxyCodeLine{00140     std::cout << \textcolor{stringliteral}{"{}ptrptr = "{}} << **ptrptr << std::endl; \textcolor{comment}{// first indirection to get pointer to int, second indirection to get int value}}
\DoxyCodeLine{00141 }
\DoxyCodeLine{00142     \textcolor{keywordtype}{int} **pointer\_array = \textcolor{keyword}{new} \textcolor{keywordtype}{int}*[10]; \textcolor{comment}{// allocate an array of 10 int pointers}}
\DoxyCodeLine{00147 \textcolor{comment}{}    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00148 \}}
\DoxyCodeLine{00149 }

\end{DoxyCode}
