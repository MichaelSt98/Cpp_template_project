<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.8.20"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Cpp concept project: learningCpp/Basics/Functions.h File Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen-custom.css" rel="stylesheet" type="text/css" />
	<!-- Add icon library -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!-- Add font awesome icons -->
</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation for learningCpp/Basics/Functions.h File Reference
			</span>
			<!-- <span class="search">
				<input type="text" placeholder="Search" onkeydown="search(this,event);">
			</span> -->
		</div>
	<div class="icon-bar">
		<a href="https://de-de.facebook.com/" class="fa fa-facebook"></a>
		<a href="https://twitter.com/?lang=de" class="fa fa-twitter"></a>
		<a href="https://github.com/" class="fa fa-github"></a>
		<a href="https://www.youtube.com/?gl=DE&hl=de" class="fa fa-youtube"></a>
		<a href="https://www.linkedin.com/login/de" class="fa fa-linkedin"></a>
		<a href="https://about.gitlab.com/?utm_medium=cpc&utm_source=google&utm_campaign=brand_emea_pr_rsa_br_exact&utm_content=homepage_digital_x-pr_english_&_bt=363211725518&_bk=gitlab&_bm=e&_bn=g&_bg=75294586319&gclid=EAIaIQobChMI1rKi_ICR7QIVV53VCh2igg88EAAYASAAEgKcFPD_BwE" class="fa fa-gitlab"></a>
		<a href="https://uni-tuebingen.de/" class="fa fa-university"></a>
		<a href="https://slack.com/intl/de-de/" class="fa fa-slack"></a>
		<a href="#" class="fa fa-share-alt"></a>
		<a href="https://de.wikipedia.org/wiki/Wikipedia:Hauptseite" class="fa fa-wikipedia-w"></a>
	</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_94b3207fdcdf159a761ccdefa33582c9.html">learningCpp</a></li><li class="navelem"><a class="el" href="dir_e505aaa46ea9b50afa27cb8407da5c18.html">Basics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;array&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Functions.h:</div>
<div class="dyncontent">
<div class="center"><img src="_functions_8h__incl.png" border="0" usemap="#alearning_cpp_2_basics_2_functions_8h" alt=""/></div>
<map name="learning_cpp_2_basics_2_functions_8h" id="alearning_cpp_2_basics_2_functions_8h">
<area shape="rect" title=" " alt="" coords="6,5,141,47"/>
<area shape="rect" title=" " alt="" coords="5,95,56,121"/>
<area shape="rect" title=" " alt="" coords="80,95,152,121"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_functions_8h__dep__incl.png" border="0" usemap="#alearning_cpp_2_basics_2_functions_8hdep" alt=""/></div>
<map name="learning_cpp_2_basics_2_functions_8hdep" id="alearning_cpp_2_basics_2_functions_8hdep">
<area shape="rect" title=" " alt="" coords="5,5,140,47"/>
<area shape="rect" href="_functions_8cpp.html" title=" " alt="" coords="5,95,140,136"/>
</map>
</div>
</div>
<p><a href="_functions_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af889c468d4cc52789ef37bf08716b68a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#af889c468d4cc52789ef37bf08716b68a">pass_by_value</a> (int x)</td></tr>
<tr class="memdesc:af889c468d4cc52789ef37bf08716b68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function passing argument by value.  <a href="_functions_8h.html#af889c468d4cc52789ef37bf08716b68a">More...</a><br /></td></tr>
<tr class="separator:af889c468d4cc52789ef37bf08716b68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec956d71e1eccd51ef422341e5f3049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a5ec956d71e1eccd51ef422341e5f3049">pass_by_reference</a> (int &amp;x)</td></tr>
<tr class="memdesc:a5ec956d71e1eccd51ef422341e5f3049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function passing argument by reference.  <a href="_functions_8h.html#a5ec956d71e1eccd51ef422341e5f3049">More...</a><br /></td></tr>
<tr class="separator:a5ec956d71e1eccd51ef422341e5f3049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae15f6bff98d72da855b7b7816c8af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a9ae15f6bff98d72da855b7b7816c8af3">pass_by_address</a> (int *x)</td></tr>
<tr class="memdesc:a9ae15f6bff98d72da855b7b7816c8af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function passing argument by address.  <a href="_functions_8h.html#a9ae15f6bff98d72da855b7b7816c8af3">More...</a><br /></td></tr>
<tr class="separator:a9ae15f6bff98d72da855b7b7816c8af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c77c8db78c984abd2c2d9526586d6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#af8c77c8db78c984abd2c2d9526586d6a">return_by_value</a> ()</td></tr>
<tr class="memdesc:af8c77c8db78c984abd2c2d9526586d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returning value by value.  <a href="_functions_8h.html#af8c77c8db78c984abd2c2d9526586d6a">More...</a><br /></td></tr>
<tr class="separator:af8c77c8db78c984abd2c2d9526586d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae748ac036cd3cb10bbb279962e5e9a7c"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#ae748ac036cd3cb10bbb279962e5e9a7c">return_by_reference</a> ()</td></tr>
<tr class="memdesc:ae748ac036cd3cb10bbb279962e5e9a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returning value by reference.  <a href="_functions_8h.html#ae748ac036cd3cb10bbb279962e5e9a7c">More...</a><br /></td></tr>
<tr class="separator:ae748ac036cd3cb10bbb279962e5e9a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3281d80fbae3ea726d13d7f2bdf21a3a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a3281d80fbae3ea726d13d7f2bdf21a3a">return_by_address</a> ()</td></tr>
<tr class="memdesc:a3281d80fbae3ea726d13d7f2bdf21a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returning value by address.  <a href="_functions_8h.html#a3281d80fbae3ea726d13d7f2bdf21a3a">More...</a><br /></td></tr>
<tr class="separator:a3281d80fbae3ea726d13d7f2bdf21a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24400242b18720c6ffef03116f165e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a8a24400242b18720c6ffef03116f165e">overload_add</a> (int a, int b)</td></tr>
<tr class="memdesc:a8a24400242b18720c6ffef03116f165e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function adding two values.  <a href="_functions_8h.html#a8a24400242b18720c6ffef03116f165e">More...</a><br /></td></tr>
<tr class="separator:a8a24400242b18720c6ffef03116f165e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460482522f520f74818976c486ad7809"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a460482522f520f74818976c486ad7809">overload_add</a> (int a, int b, int c)</td></tr>
<tr class="memdesc:a460482522f520f74818976c486ad7809"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Overloaded) Function adding three values  <a href="_functions_8h.html#a460482522f520f74818976c486ad7809">More...</a><br /></td></tr>
<tr class="separator:a460482522f520f74818976c486ad7809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8346e6426fc45cf4b2a1142c2b24e987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a8346e6426fc45cf4b2a1142c2b24e987">func_default_arg</a> (int x, int y=10)</td></tr>
<tr class="memdesc:a8346e6426fc45cf4b2a1142c2b24e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function with default argument (optional parameter)  <a href="_functions_8h.html#a8346e6426fc45cf4b2a1142c2b24e987">More...</a><br /></td></tr>
<tr class="separator:a8346e6426fc45cf4b2a1142c2b24e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efc0d291d6f7ee1784b2c23409adbf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a5efc0d291d6f7ee1784b2c23409adbf5">countDown</a> (int count)</td></tr>
<tr class="memdesc:a5efc0d291d6f7ee1784b2c23409adbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple recursive function.  <a href="_functions_8h.html#a5efc0d291d6f7ee1784b2c23409adbf5">More...</a><br /></td></tr>
<tr class="separator:a5efc0d291d6f7ee1784b2c23409adbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c7a90f893a6d7838dc10248edd16f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a69c7a90f893a6d7838dc10248edd16f2">ellipsis_example</a> (int count,...)</td></tr>
<tr class="memdesc:a69c7a90f893a6d7838dc10248edd16f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function using ellipsis.  <a href="_functions_8h.html#a69c7a90f893a6d7838dc10248edd16f2">More...</a><br /></td></tr>
<tr class="separator:a69c7a90f893a6d7838dc10248edd16f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9a6c9fecee433db5438afa8cae8670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_functions_8h.html#abd9a6c9fecee433db5438afa8cae8670">lambda_example</a> (std::array&lt; std::string_view, 4 &gt; arr)</td></tr>
<tr class="memdesc:abd9a6c9fecee433db5438afa8cae8670"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple lambda function.  <a href="_functions_8h.html#abd9a6c9fecee433db5438afa8cae8670">More...</a><br /></td></tr>
<tr class="separator:abd9a6c9fecee433db5438afa8cae8670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ae913e2a7b3479faa6afe7c6948cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f4ae913e2a7b3479faa6afe7c6948cd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_functions_8h.html#a3f4ae913e2a7b3479faa6afe7c6948cd">max</a> (T x, T y)</td></tr>
<tr class="memdesc:a3f4ae913e2a7b3479faa6afe7c6948cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple template function.  <a href="_functions_8h.html#a3f4ae913e2a7b3479faa6afe7c6948cd">More...</a><br /></td></tr>
<tr class="separator:a3f4ae913e2a7b3479faa6afe7c6948cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="autotoc_md102"></a>
Function parameters and arguments</h1>
<h2><a class="anchor" id="autotoc_md103"></a>
Pass by value</h2>
<p>By default, non-pointer arguments in C++ are passed by value. When an argument is <b>passed by value</b>, the argument's value is copied into the value of the corresponding function parameter. Therefore the original argument can not be modified by the function!</p>
<h3><a class="anchor" id="autotoc_md104"></a>
Pros</h3>
<ul>
<li>Arguments can be anything</li>
<li>Arguments are never changed by the function (prevents possibly unwanted side effects)</li>
</ul>
<h3><a class="anchor" id="autotoc_md105"></a>
Cons</h3>
<ul>
<li>Copying classes and structs can incur a significant performance penalty</li>
</ul>
<h3><a class="anchor" id="autotoc_md106"></a>
When to use</h3>
<ul>
<li>When passing fundamental data type and enumerators, and the function does not need to change the argument.</li>
</ul>
<h3><a class="anchor" id="autotoc_md107"></a>
When not to use</h3>
<ul>
<li>When passing structs or classes (including std::array, std::vector, and std::string)</li>
</ul>
<h2><a class="anchor" id="autotoc_md108"></a>
Pass by reference</h2>
<p>To <b>pass</b> a variable <b>by reference</b>, simply declare the function parameters as references. When the function is called the function parameter becomes a reference to the argument being called with, so that any changes made to the reference are passed through to the argument!</p>
<p>Since functions can have only one return value, references or rather reference function parameters can be used to return multiple values.</p>
<h3><a class="anchor" id="autotoc_md109"></a>
read-only pass by reference</h3>
<p>If it is undesirable to change an argument, make it read-only by passing it as <b>const reference</b>, so that an error occurs if the function tries to change the argument.</p>
<p>That's useful, since</p><ul>
<li>It enlists the compilers help in ensuring values that shouldn’t be changed aren’t changed (the compiler will throw an error if you try, like in the above example).</li>
<li>It tells the programmer that the function won’t change the value of the argument. This can help with debugging.</li>
<li>You can’t pass a const argument to a non-const reference parameter. Using const parameters ensures you can pass both non-const and const arguments to the function.</li>
<li>Const references can accept any type of argument, including non-const l-values, const l-values, and r-values.</li>
</ul>
<h3><a class="anchor" id="autotoc_md110"></a>
Pros</h3>
<ul>
<li>References allow a function to change the value of the argument, which is sometimes useful. Otherwise, const references can be used to guarantee the function won’t change the argument.</li>
<li>Because a copy of the argument is not made, pass by reference is fast, even when used with large structs or classes.</li>
<li>References can be used to return multiple values from a function (via out parameters).</li>
<li>References must be initialized, so there’s no worry about null values.</li>
</ul>
<h3><a class="anchor" id="autotoc_md111"></a>
Cons</h3>
<ul>
<li>Because a non-const reference cannot be initialized with a const l-value or an r-value (e.g. a literal or an expression), arguments to non-const reference parameters must be normal variables.</li>
<li>It can be hard to tell whether an argument passed by non-const reference is meant to be input, output, or both. Judicious use of const and a naming suffix for out variables can help.</li>
<li>It’s impossible to tell from the function call whether the argument may change. An argument passed by value and passed by reference looks the same. We can only tell whether an argument is passed by value or reference by looking at the function declaration. This can lead to situations where the programmer does not realize a function will change the value of the argument.</li>
</ul>
<h3><a class="anchor" id="autotoc_md112"></a>
When to use</h3>
<ul>
<li>When passing structs or classes (const if read-only is wanted)</li>
<li>When the function needs to modify an argument</li>
<li>When the type information of a fixed array is required</li>
</ul>
<h2><a class="anchor" id="autotoc_md113"></a>
Pass by address</h2>
<p>There is one more way to pass variables to functions, and that is by address. <b>Passing an argument by address</b> involves passing the address of the argument variable rather than the argument variable itself. Because the argument is an address, the function parameter must be a pointer. The function can then dereference the pointer to access or change the value being pointed to.</p>
<p><b>Remember that fixed arrays decay into pointers when passed to a function</b>, therefore the length of the array has to be passed separately.</p>
<p>Addresses are actually passed by value, so by changing the function parameter itself, the original pointer argument will not be changed.</p>
<p>To change the address an argument points to, just pass the addresses by reference.</p>
<h3><a class="anchor" id="autotoc_md114"></a>
read-only pass by address</h3>
<p>If it is undesirable to change an argument, make it read-only by passing it as <b>const pointer</b>, so that an error occurs if the function tries to change the argument.</p>
<h3><a class="anchor" id="autotoc_md115"></a>
Pros</h3>
<ul>
<li>Pass by address allows a function to change the value of the argument, which is sometimes useful. Otherwise, const can be used to guarantee the function won’t change the argument. (However, if you want to do this with a non-pointer, you should use pass by reference instead).</li>
<li>Because a copy of the argument is not made, it is fast, even when used with large structs or classes.</li>
<li>We can return multiple values from a function via out parameters.</li>
</ul>
<h3><a class="anchor" id="autotoc_md116"></a>
Cons</h3>
<ul>
<li>Because literals (excepting C-style string literals) and expressions do not have addresses, pointer arguments must be normal variables.</li>
<li>All values must be checked to see whether they are null. Trying to dereference a null value will result in a crash. It is easy to forget to do this.</li>
<li>Because dereferencing a pointer is slower than accessing a value directly, accessing arguments passed by address is slower than accessing arguments passed by value.</li>
</ul>
<h3><a class="anchor" id="autotoc_md117"></a>
When to use</h3>
<ul>
<li>When passing built-in arrays (if you’re okay with the fact that they’ll decay into a pointer).</li>
<li>When passing a pointer and nullptr is a valid argument logically.</li>
</ul>
<h3><a class="anchor" id="autotoc_md118"></a>
When not to use</h3>
<ul>
<li>When passing a pointer and nullptr is not a valid argument logically (use pass by reference).</li>
<li>When passing structs or classes (use pass by reference).</li>
<li>When passing fundamental types (use pass by value).</li>
</ul>
<h2><a class="anchor" id="autotoc_md119"></a>
Returning values by value, reference and address</h2>
<p>This is quite similar to passing arguments to functions. In fact, returning values from a function to its caller by value, address or reference <b>works almost exactly the same way as passing arguments to a function, with the same upsides and downsides</b>.</p>
<p><b>Attention</b>: Since local variables in a function go out of scope and are destroyed, this needs to be considered!</p>
<h3><a class="anchor" id="autotoc_md120"></a>
Return by value</h3>
<p>To use, when</p><ul>
<li>returning variables that were declared inside the function</li>
<li>returning function arguments that were passed by value</li>
</ul>
<p><b>Not</b> to use, when</p><ul>
<li>returning a built-in array or pointer (use return by address instead!)</li>
<li>returning a large struct or class (use return by reference instead!)</li>
</ul>
<h3><a class="anchor" id="autotoc_md121"></a>
Return by address</h3>
<p>Not possible for literals or expressions (no address)!</p>
<p>To use, when</p><ul>
<li>returning dynamically allocated memory and there is no type to handle the allocation</li>
<li>returning function arguments that were passed by address</li>
</ul>
<p><b>Not</b> to use, when</p><ul>
<li>returning variables declared inside the function or parameters passed by value (use return by value instead!)</li>
<li>returning a large struct or class that was passed by reference (use return by refernce instead!)</li>
</ul>
<h2><a class="anchor" id="autotoc_md122"></a>
Return by reference</h2>
<p>Not possible for literals or expressions (no address)!</p>
<p>To use, when</p><ul>
<li>returning a reference parameter</li>
<li>returning a member of an object that was passed into the function by reference or address</li>
<li>returning a large struct or class that will not be destroyed at the end of the function</li>
</ul>
<p><b>Not</b> to use, when</p><ul>
<li>returning variables declared inside the function or parameters passed by value (use return by value instead!)</li>
<li>returning a built-in array or pointer value (use return by address)</li>
</ul>
<h2><a class="anchor" id="autotoc_md123"></a>
Returning multiple values</h2>
<p>To return multiple values</p><ul>
<li>a struct (or in principle a class)</li>
<li>std::tuple can be used!</li>
</ul>
<h1><a class="anchor" id="autotoc_md124"></a>
Function overloading</h1>
<p><b>Function overloading is a feature of C++ that allows us to create multiple functions with the same name, so long as they have different parameters.</b></p>
<p><b>Attention:</b> Function return types are not considered distinct!</p>
<h1><a class="anchor" id="autotoc_md125"></a>
Default arguments</h1>
<p>A default argument is a default value provided for a function parameter. If the user does not supply an explicit argument for a parameter with a default argument, the default value will be used. If the user does supply an argument for the parameter, the user-supplied argument is used. Because the user can choose whether to supply a specific argument value, or use the default, a parameter with a default value provided is often called an optional parameter.</p>
<h1><a class="anchor" id="autotoc_md126"></a>
Function pointers</h1>
<p><b>Function pointers</b> point to functions!</p>
<ul>
<li>non-const function pointer: int (<em>fcnPtr)()</em></li>
<li><em>const function pointer: int (*const fcnPtr)()</em></li>
<li><em>use type aliases to make function pointers *prettier</em>: using ValidateFunction = bool(*)(int, int)</li>
<li>using std::function (from e.g. &lt;functional&gt;): std::function&lt;bool(int, int)&gt; fcn</li>
</ul>
<p>Using function pointers, functions can be passed to other functions as arguments.</p>
<h1><a class="anchor" id="autotoc_md127"></a>
The stack and the heap</h1>
<p>The memory a program uses is divided into:</p>
<ul>
<li>The code segment (also called a text segment), where the compiled program sits in memory. The code segment is typically read-only.</li>
<li>The bss segment (also called the uninitialized data segment), where zero-initialized global and static variables are stored.</li>
<li>The data segment (also called the initialized data segment), where initialized global and static variables are stored.</li>
<li>The heap, where dynamically allocated variables are allocated from.</li>
<li>The call stack, where function parameters, local variables, and other function-related information are stored.</li>
</ul>
<h2><a class="anchor" id="autotoc_md128"></a>
Heap</h2>
<p>The heap segment (also known as the “free store”) keeps track of memory used for dynamic memory allocation (when using <em>new</em> and <em>delete</em>).</p>
<h2><a class="anchor" id="autotoc_md129"></a>
Stack</h2>
<p>The call stack (usually referred to as “the stack”) has a much more interesting role to play. The call stack keeps track of all the active functions (those that have been called but have not yet terminated) from the start of the program to the current point of execution, and handles allocation of all function parameters and local variables.</p>
<h1><a class="anchor" id="autotoc_md130"></a>
Recursion</h1>
<p>Recursive functions are functions that call themselves.</p>
<h1><a class="anchor" id="autotoc_md131"></a>
Variable number of parameters - Ellipsis</h1>
<p>All parameters a function will take must be known in advance (even if they have default values). However, there are certain cases where it can be useful to be able to pass a variable number of parameters to a function. C++ provides a special specifier known as ellipsis *...*.</p>
<p><b>Avoid using ellipsis, for many reasons ... !</b></p>
<h1><a class="anchor" id="autotoc_md132"></a>
Lambdas - anonymous functions</h1>
<p>See <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/">Lambdas</a> for reference!</p>
<p>A <b>lambda expression</b> (also <em>lambda</em> or <em>closure</em>) allows to define an anonymous function inside another function.</p>
<p>The syntax is: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">[ captureClause ] ( parameters ) -&gt; returnType</div>
<div class="line">{</div>
<div class="line">    statements;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Consequently a trivial lambda looks like: <code>[]() {}</code>.</p>
<p>In actuality, lambdas aren’t functions (which is part of how they avoid the limitation of C++ not supporting nested functions). They’re a special kind of object called a <b>functor</b>. <b>Functors</b> are objects that contain an overloaded operator() that make them callable like a function.</p>
<p><b>Use auto when initializing variables with lambdas, and std::function if you can’t initialize the variable with the lambda.</b></p>
<h1><a class="anchor" id="autotoc_md133"></a>
Function templates</h1>

<p class="definition">Definition in file <a class="el" href="_functions_8h_source.html">Functions.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5efc0d291d6f7ee1784b2c23409adbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efc0d291d6f7ee1784b2c23409adbf5">&#9670;&nbsp;</a></span>countDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void countDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple recursive function. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00057">57</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;{</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;push &quot;</span> &lt;&lt; count &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">if</span> (count &gt; 1) <span class="comment">// termination condition</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <a class="code" href="_functions_8cpp.html#a5efc0d291d6f7ee1784b2c23409adbf5">countDown</a>(count-1);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;pop &quot;</span> &lt;&lt; count &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5_cgraph.png" border="0" usemap="#a_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5_cgraph" alt=""/></div>
<map name="_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5_cgraph" id="a_functions_8h_a5efc0d291d6f7ee1784b2c23409adbf5_cgraph">
<area shape="rect" title="A simple recursive function." alt="" coords="5,29,93,56"/>
<area shape="rect" href="_functions_8cpp.html#a5efc0d291d6f7ee1784b2c23409adbf5" title="A simple recursive function." alt="" coords="141,29,229,56"/>
</map>
</div>

</div>
</div>
<a id="a69c7a90f893a6d7838dc10248edd16f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c7a90f893a6d7838dc10248edd16f2">&#9670;&nbsp;</a></span>ellipsis_example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ellipsis_example </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function using ellipsis. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00083">83</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                                      {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordtype">double</span> sum{ 0 };</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160; </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// We access the ellipsis through a va_list, so let&#39;s declare one</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    va_list list;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">// We initialize the va_list using va_start.  The first parameter is</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">// the list to initialize.  The second parameter is the last non-ellipsis</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">// parameter.</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    va_start(list, count);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160; </div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="comment">// Loop through all the ellipsis arguments</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> arg{ 0 }; arg &lt; count; ++arg)</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="comment">// We use va_arg to get parameters out of our ellipsis</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="comment">// The first parameter is the va_list we&#39;re using</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="comment">// The second parameter is the type of the parameter</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        sum += va_arg(list, <span class="keywordtype">int</span>);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160; </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="comment">// Cleanup the va_list when we&#39;re done.</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    va_end(list);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160; </div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;average = &quot;</span> &lt;&lt; sum / count &lt;&lt; std::endl;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8346e6426fc45cf4b2a1142c2b24e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8346e6426fc45cf4b2a1142c2b24e987">&#9670;&nbsp;</a></span>func_default_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void func_default_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function with default argument (optional parameter) </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00052">52</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                    {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd9a6c9fecee433db5438afa8cae8670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9a6c9fecee433db5438afa8cae8670">&#9670;&nbsp;</a></span>lambda_example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lambda_example </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::string_view, 4 &gt;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple lambda function. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00067">67</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                                     {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> found{ std::find_if(arr.begin(), arr.end(),</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                   [](std::string_view str) <span class="comment">// here&#39;s our lambda, no capture clause</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                   {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                       return (str.find(<span class="stringliteral">&quot;nut&quot;</span>) != std::string_view::npos);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                   }) };</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160; </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">if</span> (found == arr.end())</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;No nuts\n&quot;</span>;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    }</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; *found &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    }</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f4ae913e2a7b3479faa6afe7c6948cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4ae913e2a7b3479faa6afe7c6948cd">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple template function. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00109">109</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                                      {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">return</span> (x &gt; y) ? x : y;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a24400242b18720c6ffef03116f165e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a24400242b18720c6ffef03116f165e">&#9670;&nbsp;</a></span>overload_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int overload_add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function adding two values. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00042">42</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                               {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;overload_add(int a, int b)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">return</span> a + b;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a460482522f520f74818976c486ad7809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460482522f520f74818976c486ad7809">&#9670;&nbsp;</a></span>overload_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int overload_add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Overloaded) Function adding three values </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00047">47</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                                      {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;overload_add(int a, int b, int c)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> a + b + c;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ae15f6bff98d72da855b7b7816c8af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae15f6bff98d72da855b7b7816c8af3">&#9670;&nbsp;</a></span>pass_by_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pass_by_address </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function passing argument by address. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00018">18</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                               {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;func: pass_by_address(int *ptr)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;ptr = 4&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    *ptr = 4;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ec956d71e1eccd51ef422341e5f3049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec956d71e1eccd51ef422341e5f3049">&#9670;&nbsp;</a></span>pass_by_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pass_by_reference </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function passing argument by reference. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00012">12</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                               {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;func: pass_by_reference(int &amp;x)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;x += 1&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    x = x + 1;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af889c468d4cc52789ef37bf08716b68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af889c468d4cc52789ef37bf08716b68a">&#9670;&nbsp;</a></span>pass_by_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pass_by_value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function passing argument by value. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00007">7</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;                          {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;func: pass_by_value(int x)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3281d80fbae3ea726d13d7f2bdf21a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3281d80fbae3ea726d13d7f2bdf21a3a">&#9670;&nbsp;</a></span>return_by_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* return_by_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returning value by address. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00036">36</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                         {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;func: return_by_address()&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordtype">int</span> value{ 2 };</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">return</span> &amp;value; <span class="comment">// return value by address</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;} <span class="comment">// value destroyed here</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae748ac036cd3cb10bbb279962e5e9a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae748ac036cd3cb10bbb279962e5e9a7c">&#9670;&nbsp;</a></span>return_by_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; return_by_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returning value by reference. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00030">30</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                           {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;func: return_by_reference()&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordtype">int</span> value{ 2 };</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> value; <span class="comment">// return a refernce to value</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8c77c8db78c984abd2c2d9526586d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c77c8db78c984abd2c2d9526586d6a">&#9670;&nbsp;</a></span>return_by_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int return_by_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returning value by value. </p>

<p class="definition">Definition at line <a class="el" href="_functions_8cpp_source.html#l00024">24</a> of file <a class="el" href="_functions_8cpp_source.html">Functions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                      {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;func: return_by_value()&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordtype">int</span> value{ 2 };</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="keywordflow">return</span> value; <span class="comment">// a copy of value will be returned</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;} <span class="comment">// value desroyed here</span></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="a_functions_8cpp_html_a5efc0d291d6f7ee1784b2c23409adbf5"><div class="ttname"><a href="_functions_8cpp.html#a5efc0d291d6f7ee1784b2c23409adbf5">countDown</a></div><div class="ttdeci">void countDown(int count)</div><div class="ttdoc">A simple recursive function.</div><div class="ttdef"><b>Definition:</b> <a href="_functions_8cpp_source.html#l00057">Functions.cpp:57</a></div></div>
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    Cpp concept project  - learningCpp/Basics/Functions.h File Reference<br />
    Generated on Fri Dec 11 2020 11:06:56 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.20
  </small></address>
</body>
</html>